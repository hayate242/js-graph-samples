<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <script src="js/three.min.js"></script>
  <script src="js/controls/OrbitControls.js"></script>

  <script>
    // ページの読み込みを待つ
    window.addEventListener('load', init);

    function init() {
      // サイズを指定
      const width = 960;
      const height = 540;
      // 刻み幅
      const stride = 0.2;
      // 円の半径
      const radius = 100;
      // piechartの1sectorの角度
      const sectorAngle = 45;

      function abs(val) {
        return val < 0 ? -val : val;
      };

      // レンダラーを作成
      const renderer = new THREE.WebGLRenderer({
        // antialias: true,
        canvas: document.querySelector('#myCanvas'),
      });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(width, height);

      // シーンを作成
      const scene = new THREE.Scene();

      // カメラを作成
      const camera = new THREE.PerspectiveCamera(45, width / height);
      // カメラの初期座標を設定
      camera.position.set(-81, 243, 465);
      // カメラコントローラーを作成
      const controls = new THREE.OrbitControls(camera);
      controls.minDistance = radius*2;
      controls.maxDistance = Infinity;
      controls.maxPolarAngle = Math.PI/2;

      camera.lookAt(new THREE.Vector3(0, 0, 0));

      // // 地面を作成
      scene.add(new THREE.GridHelper(600));
      scene.add(new THREE.AxesHelper(300));
      // 平行光源
      const directionalLight = new THREE.DirectionalLight(0xFFFFFF);
      directionalLight.position.set(1, 1, 1);
      scene.add(directionalLight);
      // 環境光源
      const ambientLight = new THREE.AmbientLight(0x333333);
      scene.add(ambientLight);


      // 角度から座標を取得(x,z)
      const getRotPosition = (angle, radius) => {
        // ラジアンに変換する
        const radian = angle * Math.PI / 180;
        // 角度に応じて位置を設定
        var x = radius * Math.sin(radian);
        var z = radius * Math.cos(radian);
        
        var positions = {
          x: x,
          z: z
        };
        return positions;
      }
      //乱数生成最大値・最小値を引数に持つ関数
      const getRandom = ( min, max ) => {
          var random = Math.floor( Math.random() * (max + 1 - min) ) + min;
          return random;
      }
      //乱数生成最大値・最小値を引数に持つ関数
      const getSin = ( angle ) => {
          // ラジアンに変換する
          const radian = angle * Math.PI / 180;
          // 角度に応じて位置を設定
          const sin = 10 * Math.sin(10*radian) + 40 + 10*radian/2;
          return sin;
      }
      // chart 描く
      let prev_damage_position = 0;
      // マウスとの交差を調べたいものは配列に格納する
      const meshList = [];
      // グループを作る
      const sectorlist = [];
      var sectorNum = 0;

      const drowPie = (start, end, chartColor) => {
        //geometryの宣言と生成
        var geometry = new THREE.Geometry();
        // 3D空間にグループを追加する
        sectorlist[sectorNum] = new THREE.Group();
        scene.add(sectorlist[sectorNum]);

        for(var i = start; i < end; i+= stride){
          const positions = getRotPosition(i, radius);

          
          // draw pie
          geometry.vertices.push( new THREE.Vector3( 0, 0, 0) ); 
          geometry.vertices.push( new THREE.Vector3( positions.x, 0, positions.z) ); 
          geometry.vertices.push( new THREE.Vector3( positions.x, 15, positions.z) ); 
          geometry.vertices.push( new THREE.Vector3( 0, 15, 0) ); 
          //線オブジェクトの生成	
          var line = new THREE.Line( geometry, new THREE.LineBasicMaterial( { color: chartColor} ) );
          
          //scenelistにlineを追加
          sectorlist[sectorNum].add(line);

          // 負荷のグラフ
          //geometryの宣言と生成
          var damage_geometry = new THREE.Geometry();
          if(i == 0){
            prev_damage_position = getSin(i);
          }else if( i < 360 ){
            const damage_position = getSin(i);
            //頂点座標の追加
            damage_geometry.vertices.push( new THREE.Vector3( positions.x, prev_damage_position, positions.z) ); 
            damage_geometry.vertices.push( new THREE.Vector3( positions.x, damage_position, positions.z) ); 
            var material = new THREE.LineBasicMaterial( { color: 0xffffff} );
            material.linewidth = 3;
            //線オブジェクトの生成	
            line = new THREE.Line( damage_geometry, material );
            //sceneにlineを追加
            scene.add( line );
            prev_damage_position = damage_position;
          } 
        }
        sectorNum++;
      }
      // textを描く
      const drawText = (text, angle) => {
        const positions = getRotPosition(angle, radius*0.7);

        const loader = new THREE.FontLoader();
        loader.load('fonts/helvetiker_regular.typeface.json', function(font){
          const textGeometry = new THREE.TextGeometry(text, {
            font: font,
            size: 20,
            height: 5,
            curveSegments: 12
          });
          const materials = [
            new THREE.MeshBasicMaterial( { color: 0xffffff, overdraw: 0.5 } ),
            new THREE.MeshBasicMaterial( { color: 0x000000, overdraw: 0.5 } )
          ];
          const textMesh = new THREE.Mesh(textGeometry, materials);
          textMesh.position.set(positions.x-10, 11, positions.z-10);
          textMesh.rotation.set(-Math.PI/2, 0, -Math.PI/2);
          scene.add(textMesh);
        });
      }

      /*
        *
        * use plot functions from here
        * 
        * 
        * 
      */
      // 画像を指定したmaterialの用意
      var material = new THREE.MeshBasicMaterial( {
        map:THREE.ImageUtils.loadTexture('imgs/bearing_mark.png', {}, function() {renderer.render(scene, camera);})
      } );

      // 画像貼り付け用板
      var geometry = new THREE.PlaneGeometry(107*0.2, 199*0.2);
      var mesh = new THREE.Mesh( geometry, material );
      mesh.rotation.set(-Math.PI/2, 0, -Math.PI/2);
      mesh.position.set(130,10,20);
      scene.add( mesh );


      // draw vertical lines
      for(var i = 0; i <= 360; i += sectorAngle){
        const positions = getRotPosition(i, radius);
        // console.log(positions);
        // 縦の線
        var ver_geometry = new THREE.Geometry();
        ver_geometry.vertices.push( new THREE.Vector3( positions.x, 0, positions.z) );
        ver_geometry.vertices.push( new THREE.Vector3( positions.x, 80, positions.z) );
        var material = new THREE.LineBasicMaterial( { color: 0xffffff} );
        material.linewidth = 3;
        var vertical_line = new THREE.Line( ver_geometry, material );
        //sceneにlineを追加
        scene.add( vertical_line );
      }
      // draw pieChart
      var color_list = [0x42bcf4,0x41f447,0xf4f441,0xf47941,0xf4424b,0xf441eb,0xc1f441,0x4167f4];
      for(var i = 0; i < 360; i += sectorAngle){
        drowPie(i, i+sectorAngle, color_list[i/sectorAngle]);
      }
      // draw Text
      for(var angle = 1; angle <= 8; angle++){
        // A~G
        drawText( String.fromCharCode(64+angle), angle*45-25);
      }

      
      render();

      //描画
      function render() {
        renderer.render(scene, camera);
        // animation
        requestAnimationFrame(render);
      }

      // 初期化のために実行
      onResize();
      // リサイズイベント発生時に実行
      window.addEventListener('resize', onResize);
      function onResize() {
        // サイズを取得
        const width = window.innerWidth;
        const height = window.innerHeight;
        // レンダラーのサイズを調整する
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(width, height);
        // カメラのアスペクト比を正す
        camera.aspect = width / height;
        camera.updateProjectionMatrix();
      }

      // tick();

      // // 毎フレーム時に実行されるループイベントです
      // function tick() {

      //   // レンダリング
      //   renderer.render(scene, camera);
      //   requestAnimationFrame(tick);

      // }
    }
  </script>
</head>
<body>
  <!-- 親のタグの基準点をリセット -->
  <div style="position:relative; overflow: hidden; width: 960px; height: 540px;">
    <canvas id="myCanvas"></canvas>
    <!-- ライン描画用のSVG -->
    <svg width="960" height="540" style="position: absolute; top: 0; left: 0;">
      <g stroke="white">
        <line id="svgLine"
              x1="0" y1="0" x2="0" y2="0"
              stroke-width="3"/>
      </g>
    </svg>

    <!-- 座標表示用のdivタグ -->
    <div id="hud" style="position: absolute; top: 0; left: 0; background: white"></div>
  </div>
</body>
</html>