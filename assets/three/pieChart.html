<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <script src="three.min.js"></script>
  <script src="js/controls/OrbitControls.js"></script>
  <script>
    // ページの読み込みを待つ
    window.addEventListener('load', init);

    function init() {
      // サイズを指定
      const width = 960;
      const height = 540;
      // 刻み幅
      const stride = 0.3
      // 円の半径
      const radius = 100;

      function abs(val) {
        return val < 0 ? -val : val;
      };

      // レンダラーを作成
      const renderer = new THREE.WebGLRenderer({
        canvas: document.querySelector('#myCanvas'),
      });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(width, height);

      // シーンを作成
      const scene = new THREE.Scene();

      // カメラを作成
      const camera = new THREE.PerspectiveCamera(45, width / height);
      // カメラの初期座標を設定
      camera.position.set(-81, 243, 465);
      // カメラコントローラーを作成
      const controls = new THREE.OrbitControls(camera);
      controls.minDistance = radius*2;
      controls.maxDistance = Infinity; 
      controls.maxPolarAngle = Math.PI/2; 

      camera.lookAt(new THREE.Vector3(0, 0, 0));

      // // 地面を作成
      scene.add(new THREE.GridHelper(600));
      scene.add(new THREE.AxesHelper(300));

      // 角度から座標を取得(x,z)
      const getRotPosition = (angle) => {
        // ラジアンに変換する
        const radian = angle * Math.PI / 180;
        // 角度に応じて位置を設定
        var x = radius * Math.sin(radian);
        var z = radius * Math.cos(radian);
        
        var positions = {
          x: x,
          z: z
        };
        return positions;
      }
      //乱数生成最大値・最小値を引数に持つ関数
      const getRandom = ( min, max ) => {
          var random = Math.floor( Math.random() * (max + 1 - min) ) + min;
          return random;
      }
      //乱数生成最大値・最小値を引数に持つ関数
      const getSin = ( angle ) => {
          // ラジアンに変換する
          const radian = 10 * angle * Math.PI / 180;
          // 角度に応じて位置を設定
          const sin = 10 * Math.sin(radian) + 40 + radian/2;
          return sin;
      }
      // chart 描く
      let prev_damage_position = 0;
      const drowPie = (start, end, chartColor) => {
        for(var i = start; i < end; i+= stride){
          const positions = getRotPosition(i);

          //geometryの宣言と生成
          var geometry = new THREE.Geometry();
          // draw pie
          for(var j = 0; j < 15; j+=0.3){
            //頂点座標の追加
            geometry.vertices.push( new THREE.Vector3( 0, 0+j, 0) ); 
            geometry.vertices.push( new THREE.Vector3( positions.x, 0+j, positions.z) ); 
          }
          //線オブジェクトの生成	
          var line = new THREE.Line( geometry, new THREE.LineBasicMaterial( { color: chartColor} ) );
          //sceneにlineを追加
          scene.add( line );


          // 負荷のグラフ
          //geometryの宣言と生成
          var damage_geometry = new THREE.Geometry();
          // const damage_position = getRandom(15,100);
          // const next_damage_position = getRandom(15,100);
          if(i == 0){
            prev_damage_position = getSin(i);
          }else if( i < 360 ){
            const damage_position = getSin(i);
            //頂点座標の追加
            damage_geometry.vertices.push( new THREE.Vector3( positions.x, prev_damage_position, positions.z) ); 
            damage_geometry.vertices.push( new THREE.Vector3( positions.x, damage_position, positions.z) ); 
            
            //線オブジェクトの生成	
            line = new THREE.Line( damage_geometry, new THREE.LineBasicMaterial( { color: 0xffffff} ) );
            //sceneにlineを追加
            scene.add( line );
            prev_damage_position = damage_position;
          } 
        }
      }
      // draw vertical lines
      for(var i = 0; i <= 360; i+=45){
        const positions = getRotPosition(i);
        console.log(positions);
        // 縦の線
        var ver_geometry = new THREE.Geometry();
        ver_geometry.vertices.push( new THREE.Vector3( positions.x, 0, positions.z) );
        ver_geometry.vertices.push( new THREE.Vector3( positions.x, 80, positions.z) );
        var vertical_line = new THREE.Line( ver_geometry, new THREE.LineBasicMaterial( { color: 0xffffff} ) );
        //sceneにlineを追加
        scene.add( vertical_line );
      }
      
      var color_list = [0x42bcf4,0x41f447,0xf4f441,0xf47941,0xf4424b,0xf441eb,0xc1f441,0x4167f4];
      const sectorAngle = 45;
      for(var i = 0; i < 360; i += sectorAngle){
        drowPie(i, i+sectorAngle, color_list[i/sectorAngle]);
      }
    

      // 三角形を描く
      // var vertices = [
      // new THREE.Vector3(0, 0, 0),
      // new THREE.Vector3(100, 0, 0),
      // new THREE.Vector3(0, 0, 100)];

      // var faces = [new THREE.Face3(1, 0, 2)];

      // var geometry = new THREE.Geometry();
      // geometry.vertices = vertices;
      // geometry.faces = faces;
      // geometry.computeFaceNormals();

      // // var material = new THREE.MeshPhongMaterial({
      // //   color: 0x00ffff });
      // var material = new THREE.MeshBasicMaterial({ color: 0xff0000 });

      // var sector = new THREE.Mesh(geometry, material);

      // scene.add(sector);

      render();

      //描画
      function render() {
        renderer.render(scene, camera);
        // animation
        requestAnimationFrame(render);
      }

      tick();

      // 毎フレーム時に実行されるループイベントです
      function tick() {
        // console.log(camera.position)

        // レンダリング
        renderer.render(scene, camera);
        requestAnimationFrame(tick);

      }
    }
  </script>
</head>
<body>
  <canvas id="myCanvas"></canvas>
</body>
</html>